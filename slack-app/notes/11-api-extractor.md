<p align='left'>
 <a href="./10-declaration-files.md">◀ Back: Declaration Files</a>
</p>

---

# API Extractor

[API extractor](https://api-extractor.com/) is a tool that's part of Microsoft's tech stack, and
in my opinion it's one of the most under-used and under-appreciated things in the TypeScript ecosystem.

## What problems does it solve?

- Generating API documentation
- Tells you if there are any changes in your API surface associated with a code change
- Allows you to provide multiple _variants_ of your public API surface, at various levels of release maturity (i.e., "beta")

It's also monorepo-friendly, which I'll go into in more detail in the **JavaScript and TypeScript Monorepos** course.

## Setup

```sh
# Install dependencies
yarn add -D @microsoft/api-extractor @microsoft/api-documenter

# Generate an initial config file: api-extractor.json
yarn api-extractor init
```

## Configuration: The basics

API extractor consumes _your tree of declaration files_ as an input. Let's make
a tsconfig specifically for this.

#### `tsconfig.apidocs.json`

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": ".dist-types",
    "declaration": true,
    "noEmit": false,
    "emitDeclarationOnly": true,
    "jsx": "react"
  },
  "include": ["src"]
}
```

and add this `.dist-types` folder to our `.gitignore`

```diff
--- a/.gitignore
+++ b/.gitignore
@@ -115,5 +115,5 @@ dist
 .yarn/install-state.gz
 .pnp.*

+# Type information for api-extractor
+.dist-types
+# API report JSON generated by api-extractor
+temp
```

Let's try to tell typescript to build using this config file and see what happens

```sh
# build
tsc -P tsconfig.apidocs.json

# list contents of output folder
ls -p .dist-types
```

You should see something like

```
data/             type-guards.d.ts  ui/
index.d.ts        types.d.ts        utils/
```

Note the absence of `.js` files. This is _just the type information_

Next, we need to tell `api-extractor` about this. The whole point of this library is to consume a public API surface of some sort. We kind of have an app, and this is more traditionally done with a library, but there's still a lot of value here! We can create a dedicated entry point just for api-extractor

Create a new file `src/public-api-surface.ts` with the following content

#### [`src/public-api-surface.ts`](../src/public-api-surface.ts)

```ts
export {
  isChannel,
  isMessage,
  isTeam,
  isTypedArray,
} from './type-guards';
export { IChannel, IMessage, ITeam, IUser } from './types';

export { apiCall } from './utils/networking';
export { formatTimestamp } from './utils/date';

export {
  HTTPErrorKind,
  default as HTTPError,
} from './utils/http-error';

export {
  default as Deferred,
  RejectHandler,
  ResolveHandler,
} from './utils/deferred';
```

and build your declaration files again

```sh
# build
tsc -P tsconfig.apidocs.json

# list contents of output folder
ls -p .dist-types
```

You should see something like

```
data/                    type-guards.d.ts         utils/
index.d.ts               types.d.ts
public-api-surface.d.ts  ui/
```

Note the new `public-api-surface.d.ts`. This is the "main entry point" of our types, as far as api-extractor is concerned.

Open [`api-extractor.json`](../api-extractor.json) and look for `mainEntryPointFilePath`. Update it to point to your new declaration file

```diff
--- a/api-extractor.json
+++ b/api-extractor.json
@@ -45,7 +45,7 @@
    *
    * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
    */
-  "mainEntryPointFilePath": "<projectFolder>/lib/index.d.ts",
+  "mainEntryPointFilePath": "<projectFolder>/.dist-types/public-api-surface.d.ts",

   /**
```

and let's "extract the API surface"

```sh
yarn api-extractor run --local
```

You should see a few things happen

- you now have a `/etc` folder containing a markdown API report
- you have a `/temp` folder with a `.json` and `.md` version of your API report
- you'll see a bunch of warning messages in your console

You'll want to commit that `/etc` folder -- it's the "human-approved" API surface that
future changes will be compared to. Do not commit the `/temp` folder to git (it should be ignored, if you followed `.gitignore`-related instructions above).

Add a few npm-scripts to your [`package.json`](../package.json)

```diff
--- a/package.json
+++ b/package.json
@@ -6,7 +6,9 @@
     "test": "yarn test-jest && yarn test-tsd && yarn test-dtslint",
     "test-jest": "jest tests/components",
     "test-tsd": "tsd tests/types-tsd",
-    "test-dtslint": "dtslint tests/types-dtslint"
+    "test-dtslint": "dtslint tests/types-dtslint",
+    "api-report": "tsc -b tsconfig.apidocs.json && yarn api-extractor run",
+    "api-docs": "api-documenter markdown -i temp -o docs"
   },
   "devDependencies": {
```

Now you should be able to run

```sh
# Update api report with any changes
yarn update-api-report

# Analyze the current state of the code, and
# return 0 if api report is up to date
yarn api-report

# Extract the API information and generate docs
yarn api-report && yarn api-docs
```

Next, let's fix the errors in your console, it shouldn't take long

- `tsdoc-param-tag-missing-hyphen` wants `@param` JSDoc tags to look like

```
@param foo - description of foo
```

- `ae-missing-release-tag` wants everything that is exported to be marked as one of [four special JSDoc tags](https://api-extractor.com/pages/tsdoc/doc_comment_syntax/#release-tags) - `@public`, `@beta`, `@alpha` and `@internal` (in descending order of release maturity)

## Configuring the rollup

Make the following changes to your [`api-extractor.json`](../api-extractor.json) file

```diff
--- a/api-extractor.json
+++ b/api-extractor.json
@@ -181,7 +181,7 @@
     /**
      * (REQUIRED) Whether to generate the .d.ts rollup file.
      */
-    "enabled": true
+    "enabled": true,

     /**
      * Specifies the output path for a .d.ts rollup file to be generated without any trimming.
@@ -195,7 +195,7 @@
      * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
      * DEFAULT VALUE: "<projectFolder>/dist/<unscopedPackageName>.d.ts"
      */
-    // "untrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>.d.ts",
+    "untrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>-private.d.ts",

     /**
      * Specifies the output path for a .d.ts rollup file to be generated with trimming for a "beta" release.
@@ -207,7 +207,7 @@
      * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
      * DEFAULT VALUE: ""
      */
-    // "betaTrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>-beta.d.ts",
+    "betaTrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>-beta.d.ts",

     /**
      * Specifies the output path for a .d.ts rollup file to be generated with trimming for a "public" release.
@@ -221,7 +221,7 @@
      * SUPPORTED TOKENS: <projectFolder>, <packageName>, <unscopedPackageName>
      * DEFAULT VALUE: ""
      */
-    // "publicTrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>-public.d.ts",
+    "publicTrimmedFilePath": "<projectFolder>/dist/<unscopedPackageName>.d.ts"

     /**
      * When a declaration is trimmed, by default it will be replaced by a code comment such as
```

and re-run

```sh
yarn update-api-report && yarn api-docs
```

You should see some new declaration files in your `/dist` folder now

- `professional-ts.d.ts` for your public API
- `professional-ts-beta.d.ts` for your "beta" public API
- `professional-ts-private.d.ts` for your private API

You could edit your [`package.json`](../package.json) to point to the public API
`.d.ts` rollup

```diff
--- a/package.json
+++ b/package.json
@@ -63,6 +64,7 @@
     "parcel-bundler": "^1.12.4",
     "json-server": "^0.16.2"
   },
+  "types": "dist/professional-ts.d.ts",
   "name": "professional-ts",
   "version": "0.0.0",
   "description": "Mike's \"professional TypeScript\" course",
```

If a consumer wanted to use your "beta" API, they'd just have to make a small
modification to their `tsconfig.json`

```diff
  "compilerOptions": {
+    "paths": {
+      "professional-ts": ["node_modules/professional-ts/dist/professional-ts-beta.d.ts"]
+    }
  }
```

## Even more capability

There are all sorts of other capabilities of api-extractor. For example

- See what happens if your [`src/public-api-surface.ts`](../src/public-api-surface.ts) no longer exports `ITeam` -- you'd be told that you can't link to it in your documentation
- See what happens if you forget to export an interface that's part of a public API signature

You have a lot of control over what's surfaced in the api-report, vs. in the console,
and what's regarded as a warning vs. error.

All in all, this provides unparalleled visibility into how proposed code changes
would have ramifications on the public API surface of a library.

---

<p align='right'>
 <a href="./09-tests-for-types.md">Next: Tests for Types ▶</a>
</p>
